// Open TAS Controller - Connects to game consoles via a Raspberry Pi Pico
// Copyright (C) 2022  Russell Small
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// N64 controller port has 1 data pin, which is normally high. Bits are sent by
// pulling the line low - 1us for a 1, and 3us for a zero. Each bit is 4us long.
// Additionally, once the console has finish sending data to the controller, the
// line is pulled low for 1us again (appearing as a 1 bit). The controller can
// start responding soon after the line is let high again.

// Once a controller is done responding, it pulls the line low for 2us.

// All commands sent back and forth have multiple of 8 bits, however due to
// the fact that there's a handoff bit which varies in location, its not
// feasible for the pio program to send full bytes back to the main cpu.

// Instead, what we're doing is sending the raw readings. unfortunately This
// leaves the responsibility of decoding the wave to the CPU.

// sample waves (8 characters = 1us):
// 1 bit.
//         ------------------------
// -------/

// 0 bit.
//                         --------
// -----------------------/

// end bit
//                 ----------------
// ---------------/

// Timings
// A......B...T...C...T...D........A

// A: When the line first drops low
// B: When the line starts rising high for a 1 bit
// C: When the line starts rising high for the end bit
// D: When the line starts rising high for a 0 bit.
// T: the two points we make measurements

// NOTE: Using a jump instead of 2 timed `in` commands to increase response time
// when a 1 is received (important for the handoff bit)

.program n64_read
.define public F_PIO_MHZ 8
.define public F_PIO (F_PIO_MHZ * 1000000)

one_bit:
    in x 2
public start:
.wrap_target
    wait 1 pin 0
    wait 0 pin 0    [(F_PIO_MHZ * 3 / 2) - 1]
    jmp pin one_bit 
    in null 1       [F_PIO_MHZ - 2]
    in pins 1
.wrap

% c-sdk {
#include "global.h"

void n64_read_program_install(PIO pio, uint state_machine, uint offset, uint pin) {
    pio_sm_set_consecutive_pindirs(pio, state_machine, pin, 1, false);
    pio_gpio_init(pio, pin);
    
    pio_sm_config config = n64_read_program_get_default_config(offset);
    sm_config_set_in_pins(&config, pin);
    sm_config_set_jmp_pin(&config, pin);
    sm_config_set_in_shift(&config, false /*shift left*/, true /*auto push*/, 2 /*push size*/);
    sm_config_set_fifo_join(&config, PIO_FIFO_JOIN_RX);
    sm_config_set_clkdiv(&config, (float)F_CPU / (float)n64_read_F_PIO);
    
    pio_sm_init(pio, state_machine, offset + n64_read_offset_start, &config);
    pio_sm_exec(pio, state_machine, pio_encode_set(pio_x, 0b11)); // Initialize x to 0b11
}
%}
